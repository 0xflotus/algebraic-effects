(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{36:function(e,a,n){"use strict";n.r(a),n.d(a,"default",function(){return g});var t=n(3),s=n(8),m=n(9),o=n(11),p=n(10),c=n(12),r=n(0),l=n.n(r),N=n(1),g=function(e){function a(e){var n;return Object(s.a)(this,a),(n=Object(o.a)(this,Object(p.a)(a).call(this,e))).layout=null,n}return Object(c.a)(a,e),Object(m.a)(a,[{key:"render",value:function(){var e=this.props,a=e.components;Object(t.a)(e,["components"]);return l.a.createElement(N.MDXTag,{name:"wrapper",components:a},l.a.createElement(N.MDXTag,{name:"h1",components:a,props:{id:"task-monad"}},"Task monad"),l.a.createElement(N.MDXTag,{name:"p",components:a},"A lightweight asynchronous and lazy task monad. Running an effectful program returns an instance of a Task"),l.a.createElement(N.MDXTag,{name:"p",components:a},"Import it as"),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"import")," Task ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"from")," ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'@algebraic-effects/task'"),";\n",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"import")," { race, parallel, bimap, fork } ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"from")," ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'@algebraic-effects/task/fns'"),"; ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Helper functions. Also includes point-free alternatives for Task#method"))),l.a.createElement(N.MDXTag,{name:"h2",components:a,props:{id:"api"}},"API"),l.a.createElement(N.MDXTag,{name:"h3",components:a,props:{id:"task-constructor"}},"Task constructor"),l.a.createElement(N.MDXTag,{name:"p",components:a},"You can pass it the initial state for your program and run it."),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," :: (e -> (), a -> ()) -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," waitASec = Task(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},"(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"reject, resolve"),") =>")," setTimeout(resolve, ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1000"),"));")),l.a.createElement(N.MDXTag,{name:"h3",components:a,props:{id:"static-methods"}},"Static methods"),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.of"),", ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.Resolved"),l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.of")," is an alias for ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.Resolved")," which creates a resolved task with the given value.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"of")," :: a -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," a\n",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," :: a -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," a")),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.Rejected"),l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.Rejected")," creates a rejected/failed task with the given value.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Rejected")," :: e -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Rejected")," e")),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.Empty"),l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.Empty")," creates a task which will never resolve or get rejected. You can call ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"rejectWith")," or ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"resolveWith")," methods on the task instance to make the task reject or resolve.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Empty")," :: () -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Empty"))),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.fromPromise"),l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.empty")," creates a task which will never resolve or get rejected. You can call ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"rejectWith")," or ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"resolveWith")," methods on the task instance to make the task reject or resolve.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".fromPromise :: (() -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Promise")," e a) -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"Task.fromPromise(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"()")," =>")," fetch(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'/api'"),").then(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"r")," =>")," r.json()));")),l.a.createElement(N.MDXTag,{name:"p",components:a},"You can also pass it an async function as it returns a promise."),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"Task.fromPromise(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"async")," ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-keyword"}},"function"),"(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}}),") "),"{\n  ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," response = ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"await")," fetch(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'/api'"),");\n  ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"return")," response.json();\n})")),l.a.createElement(N.MDXTag,{name:"h3",components:a,props:{id:"instance-methods"}},"Instance methods"),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"fork"),l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"fork")," is the function that runs your task and allows to to handle to result of execution. ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task")," is lazy so you can compose your functions and it will only execute the chain when this method is called. When you call this method, you will recieve a cancel function in return. Calling this function will cancel your task.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).fork :: (e -> (), a -> ()) -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"CancelFunction"))),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," cancelTimeout = Task(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},"(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"_, resolve"),") =>")," setTimeout(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"()")," =>")," resolve(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"10"),"), ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1000"),"))\n  .fork(handleError, ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-built_in"}},"console"),".log); ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Will log 10 to console"),"\n\n",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Call cancelTimeout() will prevent the console.log"))),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"map"),l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"map")," method allows you to map over a value in the ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task")," i.e. transform the resolved value inside the task")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).map :: (a -> b) -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e b")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"Task.of(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"10"),")\n  .map(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"x")," =>")," x + ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1"),")\n  .fork(handleError, ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-built_in"}},"console"),".log); ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Will log 11 to console"))),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"mapRejected"),l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"mapRejected")," method allows you to map over a the rejected value in the ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task"),". So it will only map over e and ignore resolved values.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).mapRejected :: (a -> b) -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e b")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"Task.Rejected(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'Something went wrong'"),")\n  .mapRejected(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"e")," =>")," ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`ERROR: ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-subst"}},"${e}"),"`"),")\n  .fork(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-built_in"}},"console"),".error, handleSuccess); ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},'// Will log error "ERROR: Something went wrong"'))),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"chain"),l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"chain")," method allows you to map over a value in the ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task")," with a function that returns another task and merges the nested tasks. It behaves similar to how flatMap behaves with arrays.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).chain :: (a -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e' b) -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," (e|e') b")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"Task.of(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"10"),")\n  .chain(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"x")," =>")," Task(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},"(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"_, resolve"),") =>")," setTimeout(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"()")," =>")," resolve(x + ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1"),"), ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1000"),")))\n  .fork(handleError, ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-built_in"}},"console"),".log); ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Will log 11 to console after 1 second"))),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"bimap"),"\nWhere with ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"map")," you can only map over a resolved value in a Task, ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"bimap")," allows you to map over the resolved and the rejected value.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).bimap :: (e -> e', a -> a') -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e' a'")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"someTask\n  .bimap(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"e")," =>")," ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-subst"}},"${e}")," - Something went wrong`"),", x => x + ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1"),")\n  .fork(handleError, handleSuccess);")),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"fold"),l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"fold")," is similar to ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"bimap")," with the only difference being that the resolved or rejected value is wrapped.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).fold :: (e -> b, a -> b) -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," b")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"someTask\n  .fold(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"()")," =>")," ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"10"),", x => x + ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"10"),")\n  .fork(() = {}, handleResult); ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Handle result will get a 10 if the task is rejected, else, it will get (resolved value + 10)"),"\n\nsomeOtherTask\n  .fold(Either.Left, Either.Right)\n  .fork(() = {}, handleResult); ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Will convert the result into an Either"))),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"resolveWith"),", ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"rejectWith"),", ",l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"empty"),"\nThese methods allow you to ignore everything that happened before it and resolve or reject with a value or just empty out the task.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).resolveWith :: a' -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," a'\n(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).rejectWith :: e' -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Rejected")," e'\n(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).empty :: () -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Empty"))),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"toPromise"),"\nConvert the given task to a promise.\nNOTE: This will immediately execute your task.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).toPromise :: () -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Promise")," e a")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"someTask\n  .toPromise()\n  .then(handleSuccess)\n  .catch(handleError);")),l.a.createElement(N.MDXTag,{name:"h3",components:a,props:{id:"helper-functions"}},"Helper functions"),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"import")," { rejectAfter, race, parallel } ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"from")," ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'@algebraic-effects/task/fns'"),";")),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"resolveAfter"),"\nWill resolve with a given value after a delay")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"resolveAfter")," :: (",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Number"),", a) -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," a")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"resolveAfter(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1000"),", ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"5"),")\n  .fork(handleError, handleSuccess);")),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"rejectAfter"),"\nWill reject with a given value after a delay")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"rejectAfter")," :: (",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Number"),", e) -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Rejected")," e")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"rejectAfter(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1000"),", ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"5"),")\n  .fork(handleError, handleSuccess);")),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"race"),"\nResolve or Reject with the first task tha reaches completion.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"race")," :: [",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a] -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"race([ fetchResource, rejectAfter(",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"2000"),"), ])\n  .fork(handleError, handleSuccess);")),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"series"),"\nRun a given set of tasks one after the other and resolve with a list of results. Fail if one of the tasks fail.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"series")," :: [",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a] -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e [a]")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"series([ fetchResourceA, fetchResourceB,, fetchResourceC ])\n  .fork(handleError, ([ a, b, c ]) => handleSuccess(a, b, c));")),l.a.createElement(N.MDXTag,{name:"ul",components:a},l.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},l.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"parallel"),"\nRun a given set of tasks parallely. Fail if one of the tasks fail.")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"parallel")," :: [",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a] -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e [a]")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"parallel([ fetchResourceA, fetchResourceB, fetchResourceC ])\n  .fork(handleError, ([ a, b, c ]) => handleSuccess(a, b, c));")),l.a.createElement(N.MDXTag,{name:"h3",components:a,props:{id:"point-free-functions"}},"Point free functions"),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"map")," :: (a -> b) -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e b")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"mapRejected")," :: (e -> e') -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e' a")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"bimap")," :: (e -> e', a -> a') -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e' a'")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"fold")," :: (e -> b, a -> b) -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," b")),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"fork")," :: (e -> (), a -> ()) -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"CancelFunction"))),l.a.createElement(N.MDXTag,{name:"pre",components:a},l.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"toPromise")," :: ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a -> ",l.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Promise")," e b")))}}]),a}(l.a.Component)}}]);